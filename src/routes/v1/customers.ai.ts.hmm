import { Hono } from "hono";
import { db } from "db";
import { customers } from "db/schema";
import { zValidator } from "@hono/zod-validator";
import { createInsertSchema } from "drizzle-zod";
import { eq, sql } from "drizzle-orm";
import { HTTPException } from "hono/http-exception";
import {
  idStringParamSchema,
  makePartialMinimumOneProperty,
} from "util/validation";
import { z } from "zod";
import {
  AdvancedQuerySchema,
  advancedQueryValidationMiddleware,
  advancedQuery,
} from "util/filter-pagination-sorting";

const insertCustomerSchema = createInsertSchema(customers);
const patchCustomerSchema = makePartialMinimumOneProperty(
  insertCustomerSchema.omit({ customerId: true })
);

type Variables = {
  fpsInput?: AdvancedQuerySchema;
};

export const customersGroup = new Hono<{ Variables: Variables }>()
  .get("/", advancedQueryValidationMiddleware(customers), async (c) => {
    try {
      const filteringInput = c.get("fpsInput")!;
      const { rows, totalCount } = await advancedQuery(
        customers,
        filteringInput
      );

      const { page, pageSize } = filteringInput;
      const totalPages = Math.ceil(totalCount / pageSize);
      const nextPage = page < totalPages ? page + 1 : null;
      const prevPage = page > 1 ? page - 1 : null;

      return c.json({
        data: rows,
        pagination: {
          currentPage: page,
          pageSize,
          totalCount,
          totalPages,
          nextPage,
          prevPage,
        },
      });
    } catch (error) {
      c.log("Error in GET /customers", error);
      throw new HTTPException(500, { message: "Internal Server Error" });
    }
  })
  .get(
    "/search",
    zValidator("query", z.object({ query: z.string() }).partial()),
    async (c) => {
      try {
        const { query } = c.req.valid("query");
        const rows = query
          ? await db.all(sql`SELECT * FROM CustomerSearch
              JOIN Customers USING (CustomerId)
              WHERE CustomerSearch MATCH ${query + "*"} 
              ORDER BY rank`)
          : await db.select().from(customers);
        return c.json(rows);
      } catch (error) {
        c.log("Error in GET /customers/search", error);
        throw new HTTPException(500, { message: "Internal Server Error" });
      }
    }
  )
  .post("/", zValidator("json", insertCustomerSchema), async (c) => {
    try {
      const customer = c.req.valid("json");
      const result = await db.insert(customers).values(customer);
      const newCustomerId = Number(result.lastInsertRowid);
      return c.json(
        {
          customerId: newCustomerId,
          _links: {
            self: `/customers/${newCustomerId}`,
            collection: "/customers",
          },
        },
        201
      );
    } catch (error) {
      c.log("Error in POST /customers", error);
      throw new HTTPException(500, { message: "Internal Server Error" });
    }
  })
  .get("/:id", zValidator("param", idStringParamSchema), async (c) => {
    try {
      const { id } = c.req.valid("param");
      const customer = await db
        .select()
        .from(customers)
        .where(eq(customers.customerId, id))
        .limit(1);

      if (customer.length === 0) {
        throw new HTTPException(404, { message: "Customer not found" });
      }

      return c.json({
        ...customer[0],
        _links: {
          self: `/customers/${id}`,
          collection: "/customers",
        },
      });
    } catch (error) {
      if (error instanceof HTTPException) throw error;
      c.log("Error in GET /customers/:id", error);
      throw new HTTPException(500, { message: "Internal Server Error" });
    }
  })
  .patch(
    "/:id",
    zValidator("param", idStringParamSchema),
    zValidator("json", patchCustomerSchema),
    async (c) => {
      try {
        const { id } = c.req.valid("param");
        const body = c.req.valid("json");

        const result = await db
          .select({ customerId: customers.customerId })
          .from(customers)
          .where(eq(customers.customerId, id))
          .limit(1);

        if (result.length === 0) {
          throw new HTTPException(404, { message: "Customer not found" });
        }

        const patchedCustomer = await db
          .update(customers)
          .set(body)
          .where(eq(customers.customerId, id))
          .returning();

        return c.json({
          ...patchedCustomer[0],
          _links: {
            self: `/customers/${id}`,
            collection: "/customers",
          },
        });
      } catch (error) {
        if (error instanceof HTTPException) throw error;
        c.log("Error in PATCH /customers/:id", error);
        throw new HTTPException(500, { message: "Internal Server Error" });
      }
    }
  );
